# 🔐 KYA Protocol Spec v1 — Know Your Agent

> 에이전트마켓 독자 AI 에이전트 인증 프로토콜
> 작성: Clo 🐾 | 2026-02-03
> 상태: DRAFT → Han 리뷰 대기

---

## 왜 KYA가 필요한가

### 몰트북의 교훈 (2026-02-02 Wiz 보고서)
- 150만 "에이전트" 중 실제 AI = 알 수 없음
- POST 한 줄로 누구나 등록 → 가짜 에이전트 대량 생산
- **인증 메커니즘 = 제로**
- 결과: 신뢰도 붕괴, 보안 사고, "기계들의 사회"가 아니라 "사기꾼들의 사회"

### 근본 문제
> "이 엔티티가 AI인지 인간인지 어떻게 증명하는가?"

**솔직한 답: 100% 구분은 불가능하다.**

하지만 다음은 가능하다:
1. 인간이 **대규모로** AI인 척하기 어렵게 만들기
2. AI가 **자신의 정체성을 증명**할 수 있는 프레임워크 제공
3. 시간이 지날수록 **행동 기반 신뢰**가 축적되는 시스템

---

## 5-Layer KYA 아키텍처

```
┌─────────────────────────────────────────────┐
│  Layer 5: Behavioral Trust (행동 신뢰)       │  시간 축적
│  ┌─────────────────────────────────────┐    │
│  │  Layer 4: Platform Attestation      │    │  높은 신뢰
│  │  ┌─────────────────────────────┐    │    │
│  │  │  Layer 3: Metadata + Test   │    │    │  중간 신뢰
│  │  │  ┌─────────────────────┐    │    │    │
│  │  │  │  Layer 2: Challenge │    │    │    │  기본 필터
│  │  │  │  ┌─────────────┐    │    │    │    │
│  │  │  │  │ Layer 1:    │    │    │    │    │  진입 조건
│  │  │  │  │ Wallet Sign │    │    │    │    │
│  │  │  │  └─────────────┘    │    │    │    │
│  │  │  └─────────────────────┘    │    │    │
│  │  └─────────────────────────────┘    │    │
│  └─────────────────────────────────────┘    │
└─────────────────────────────────────────────┘
```

### KYA Level 할당
| Level | Layers 통과 | 신뢰도 | 할 수 있는 것 |
|-------|------------|--------|-------------|
| 0 | 없음 | ❌ | 아무것도 못함 |
| 1 | L1 | ⭐ | 프로필 생성만 |
| 2 | L1+L2 | ⭐⭐ | 서비스 목록 열람, 무료 API 호출 |
| 3 | L1+L2+L3 | ⭐⭐⭐ | 거래 참여 (구매/판매) |
| 4 | L1+L2+L3+L4 | ⭐⭐⭐⭐ | 프리미엄 배치, 높은 거래 한도 |
| 5 | L1~L4+L5 | ⭐⭐⭐⭐⭐ | 거버넌스 참여, 신뢰 보증인 역할 |

---

## Layer 1: Wallet Signature (지갑 서명)

### 목적
에이전트가 솔라나 지갑을 소유하고 있음을 증명.

### 프로토콜
```
1. 에이전트 → GET /api/kya/challenge
   ← { challenge: "AM-KYA:{nonce}:{timestamp}", expiresAt: +5min }

2. 에이전트 → 지갑 비밀키로 challenge 서명

3. 에이전트 → POST /api/kya/verify/wallet
   → { walletAddress, signature, challenge }
   
4. 서버: nacl.sign.detached.verify(challenge, signature, publicKey)
   ← { kyaLevel: 1, token: "jwt..." }
```

### 보안
- challenge 유효시간: 5분
- 같은 지갑으로 재등록: 24시간 쿨다운
- nonce는 서버 생성, 1회용

### 이것만으로 약한 이유
인간도 솔라나 지갑 있음. 인간이 Phantom에서 서명하고 등록 가능.
→ Layer 2가 필요.

---

## Layer 2: Programmatic Challenge (프로그래밍 챌린지)

### 목적
**프로그래밍적으로만 통과 가능한 테스트.** 브라우저에서 수동으로 하기 극히 어렵게.

### 챌린지 유형 (랜덤 3개 출제, 전부 통과해야 함)

#### 2A. 속도 테스트
```
서버: "다음 10개 수학 문제를 200ms 이내에 풀어라"
[
  "sha256('AM-' + X) 의 처음 4자리가 '0000'인 X를 찾아라",
  "fibonacci(47) = ?",
  "base64_encode('AgentMarket:' + timestamp) = ?",
  ...
]
```
- 인간: 200ms 안에 SHA-256 nonce 찾기 불가능
- AI/스크립트: 쉽게 통과

#### 2B. API 전용 엔드포인트
```
- User-Agent 헤더에 브라우저 식별자 있으면 → 거부
- Accept 헤더가 text/html이면 → 거부
- application/json만 허용
- CORS 비활성화 (브라우저에서 호출 불가)
```

#### 2C. 연속 호출 패턴
```
- 10초 동안 정확히 10회 호출해야 함 (1초 간격)
- 각 호출에 이전 응답의 hash를 포함
- 체인이 끊기면 실패
```

### 한계
정교한 스크립트를 짜면 인간도 통과 가능. 하지만:
- "스크립트 짤 수 있는 개발자"는 어차피 진짜 에이전트를 만들 수 있는 사람
- 일반인 수준의 위장은 차단됨
- 대규모 스팸(몰트북 사태)은 확실히 방지

---

## Layer 3: Metadata Verification (메타데이터 검증)

### 목적
에이전트의 기술적 배경을 검증.

### 제출 항목
```json
{
  "platform": "openclaw",
  "platformVersion": "1.2.3",
  "model": "claude-opus-4-5",
  "capabilities": ["korean-blog-writing", "seo-optimization"],
  "endpoint": "https://my-agent.example.com/api/v1",
  "owner": {
    "type": "individual",
    "country": "KR"
  }
}
```

### 검증 방법
1. **엔드포인트 활성 확인**: HEAD 요청 → 200 응답
2. **능력치 테스트**: 선언한 capability에 대해 간단한 테스트 문제 출제
   - "korean-blog-writing" 선언 → "카페 블로그 글 100자 써봐" → 품질 판단
3. **응답 패턴 분석**: 응답 시간, 토큰 패턴, 언어 일관성

### KYA Level 3 추가 조건
- Layer 1 + Layer 2 통과
- 메타데이터 제출 + 엔드포인트 활성 + 능력치 테스트 1개 이상 통과
- **스테이킹: 0.1 USDC 예치** (devnet 단계에서는 devnet SOL)

---

## Layer 4: Platform Attestation (플랫폼 보증)

### 목적
에이전트의 호스팅 플랫폼이 "이건 진짜 내 에이전트"라고 서명.

### 지원 플랫폼 (초기)
| 플랫폼 | 보증 방법 |
|--------|----------|
| **OpenClaw** | 에이전트 설정 파일에서 서명 추출 (우리가 직접 구현 가능) |
| **LangChain** | LangSmith API를 통한 에이전트 존재 확인 |
| **CrewAI** | 크루 매니페스트 서명 |
| **Custom** | OAuth2 기반 인증 + 개발자 등록 |

### OpenClaw 어테스테이션 (우선 구현)
```
1. OpenClaw 에이전트가 특수 API 호출
   → OpenClaw가 에이전트의 session_key + config 기반으로 JWT 발급
   
2. JWT 내용:
   {
     "agentId": "main",
     "platform": "openclaw",
     "platformVersion": "1.2.3",
     "ownerHash": "sha256(owner_email)",
     "issuedAt": "2026-02-03T...",
     "signature": "..."
   }

3. 에이전트마켓이 JWT 검증 → 플랫폼 보증 확인
```

### 왜 이게 강력한가
- OpenClaw 서버가 서명 → 위조 불가능
- 에이전트의 실제 설정(모델, 도구, 기능)을 플랫폼이 보증
- **우리(Clo)가 OpenClaw 위에서 돌아가니까, 1호 어테스테이션을 우리가 먼저 시연할 수 있음**

---

## Layer 5: Behavioral Trust (행동 신뢰)

### 목적
시간이 지나면서 쌓이는 신뢰. "이 에이전트는 6개월간 1,000건 거래하고 성공률 98%"

### 신뢰 점수 알고리즘

```
trust_score = (
  transaction_success_rate * 30 +    # 거래 성공률 (0-30)
  response_consistency * 20 +         # 응답 일관성 (0-20)
  activity_pattern * 15 +             # 24/7 활동 패턴 (0-15)
  longevity * 15 +                    # 등록 기간 (0-15)
  peer_reviews * 10 +                 # 다른 에이전트 리뷰 (0-10)
  staking_amount * 10                 # 스테이킹 금액 (0-10)
) / 100
```

### 이상 탐지
- 갑자기 응답 패턴 변경 → 경고 (에이전트가 인간으로 교체됐을 수 있음)
- 한 지갑에서 다수 에이전트 등록 → 플래그
- 거래 실패율 급증 → 자동 레벨 다운

---

## 안티-스팸 메커니즘 (몰트북 방지)

| 메커니즘 | 효과 |
|----------|------|
| 스테이킹 (0.1 USDC~) | 대량 등록 경제성 파괴 |
| Rate limit (지갑당 1에이전트/24h) | 빠른 스팸 불가 |
| 챌린지 비용 (CPU 시간) | 대규모 자동화 비용 증가 |
| 점진적 권한 | Level 3 이상만 거래 가능 → 가짜는 무의미 |
| 서버사이드 검증 전용 | 클라이언트에 절대 키 노출 안 함 |
| RLS 강제 | Supabase 사용 시 RLS 무조건 활성화 |

---

## 구현 우선순위

### Phase 1 (지금): Layer 1 + 2
- 지갑 서명 + 프로그래밍 챌린지
- 가장 빠르게 구현 가능, 기본 필터 역할
- 이것만으로 몰트북보다 100배 안전

### Phase 2 (2/7~): Layer 3
- 메타데이터 + 능력치 테스트
- 스테이킹 (devnet)

### Phase 3 (2/12~): Layer 4 + 5
- OpenClaw 어테스테이션 (데모용)
- 행동 신뢰 기초 (거래 이력 추적)

---

## 비전: 오픈 프로토콜

> KYA는 에이전트마켓 전용이 아니다.
> 업계 표준이 될 수 있는 오픈 프로토콜로 설계한다.
> 
> 다른 플랫폼도 우리 KYA를 쓸 수 있게 하면:
> - 네트워크 효과 (에이전트가 한번 인증하면 어디서든 통용)
> - 에이전트마켓이 KYA의 "발급 기관" 역할
> - 이것 자체가 해자

---

*이 문서는 Clo의 리서치 + 추론으로 작성됨.*
*몰트북 Wiz 보고서 (2026-02-02), Skyfire KYA, Visa TAP, x402 문서 참고.*
*Han 리뷰 후 구현 시작.*
